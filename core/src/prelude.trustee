; vim:ft=trustee:

; ## The HOL prelude for Trustee.

; #### true ####

(defconst
  "T" "DefTrue"
  `let f = (\x: bool. x) in f=f`)

; `|- T`
(set TrueIsTrue
  (bool_eq
    (refl `\x: bool. x`)
    (sym DefTrue)))

; prove `(x=T) = x`
(set EqTrueElim
  (bool_eq_intro
    (bool_eq TrueIsTrue (sym (assume `with x:bool. x=T`)))
    (bool_eq_intro TrueIsTrue (assume `with x:bool. x`))))

; `x = (x=T)`
(set EqTrueIntro (sym EqTrueElim))

; rule from `A |- x` to `A |- x=T`
(defn REqTrueIntro [th]
  (doc "rule from `A |- x` to `A |- x=T`")
  (def x (concl th))
  (def th1 (subst EqTrueIntro "x" x))
  (bool_eq th th1))

(defn REqTrueElim [th]
  (doc "rule from `A |- x=T` to `A |- x`")
  (def x (e_app_rhs (e_app_lhs (concl th))))
  (def th1 (subst EqTrueElim "x" x))
  (bool_eq th th1))

; #### forall ####

(defconst "forall" "DefForall"
 `\(a:type) (f:a -> bool). f = (\x:a. T)`)
(set_binder "forall" 12) ; lower than ==>

(defn RForallSubst [th e]
  (doc "rule that takes `|- forall x. P[x]` and `e`, and returns `|- P[e/x]`.")
  (def lamF (rw th :beta DefForall))
  (def eq (rw (congr lamF (refl e)) :beta))
  (def eq2 (REqTrueElim eq))
  eq2)

(defn RForallIntro [th x]
  (doc "rule that takes `F |- P[x]` and `x` with `x` not in `fvars(F)`, and returns `F |- forall x. P[x]`.")
  ; build `\x. P[x]`
  (def P (e_abs x (concl th)))
  ; get `($forall P) = (\x. P[x] = \x. T)
  (def forallp (rw (congr (congr_ty DefForall (expr_ty x)) (refl P)) :beta))
  ; get `F |- \x. P[x] = \x. T`
  (def peqt (absv x (REqTrueIntro th)))
  (def res (bool_eq peqt (sym forallp)))
  res)

; #### conjunction ####

(defconst "/\" "DefAnd"
  `\a b: bool. forall (f:bool->bool->bool). (f a b = f T T)`)
(set_infix "/\" 60 59)

; theorems on `/\`
{
  ; build `a/\b = …` from definition
  (def ab_def
    (congr DefAnd (refl `a:bool`) (refl `b:bool`)))

  (def goal (assume `a:bool /\ b:bool`))

  ; this gets `a/\b |- \f. f a b = \f. f T T`
  (def f_eq
    (rw (bool_eq goal ab_def) DefForall :beta))

  ; prove: `a/\b |- a`

  ; apply f_eq to `\x y. x=a`
  (def a_true
    (rw (congr f_eq (refl `with a:bool. \x y: bool. (a = x)`)) :beta))

  (set AndElim1
    (bool_eq
      (bool_eq
       (refl `a:bool`)
       (bool_eq a_true
         (subst EqTrueElim "x" `with a:bool. (a=a) = (a=T)`)))
      (subst EqTrueElim "x" `a:bool`)))

  ; prove: `a/\b |- b`
  (def b_true
    ; apply f_eq to `\x y. y=b`
    (rw (congr f_eq (refl `with b:bool. \x y:bool. (b=y)`)) :beta))

  (set AndElim2
    (bool_eq
      (bool_eq
       (refl `b:bool`)
       (bool_eq b_true (subst EqTrueElim "x" `with b:bool. (b=b)=(b=T)`)))
      (subst EqTrueElim "x" `b:bool`)))
}

(defn RAndElim1 [th]
  (doc "rule from `A |- a /\ b` to `A |- a`")
  (def c (concl th))
  (def a (e_app_rhs (e_app_lhs c)))
  (def b (e_app_rhs c))
  (subst AndElim1 "a" a "b" b))

(defn RAndElim2 [th]
  (doc "rule from `A |- a /\ b` to `A |- b`")
  (def c (concl th))
  (def a (e_app_rhs (e_app_lhs c)))
  (def b (e_app_rhs c))
  (subst AndElim2 "a" a "b" b))

; theorem `a, b |- a /\ b`
(set AndIntro
  {
    (def tha (REqTrueIntro (assume `a:bool`)))
    (def thb (REqTrueIntro (assume `b:bool`)))
    (def th1 (rw (congr DefAnd tha thb) DefForall :beta))
    ; prove `(\f. f T T = f T T) = (\f. T)`
    (def lemma1
      (def lhs (refl `with f: bool->bool->bool. f T T`))
      (def c (REqTrueIntro lhs))
      (absv `f:(bool->bool->bool)` c))
    (bool_eq lemma1 (sym th1))
  })

(defn RAndIntro [tha thb]
  (doc "rule from `A |- a`, `B |- b` to `A, B |- a /\ b`")
  (def a (concl tha))
  (def b (concl thb))
  (cut tha thb (subst AndIntro "a" a "b" b)))

; example:
; (print (cut TrueIsTrue (RAndIntro (assume `T`) (assume `b:bool`))))
; print: `with (b : bool). b |- with (b : bool). T /\ b`

; prove `(a /\ b) /\ c) = a /\ (b /\ c)`
(set AndAssoc
  {
    ; direct direction
    (def goal1 (assume `with a b c: bool. (a /\ b) /\ c`))
    (def th_c (RAndElim2 goal1))
    (def th_ab (RAndElim1 goal1))
    (def th_a (cut th_ab (RAndElim1 th_ab)))
    (def th_b (cut th_ab (RAndElim2 th_ab)))
    (def th_bc (RAndIntro th_b th_c))
    (def th1 (RAndIntro th_a th_bc))

    (def goal2 (assume `with a b c: bool. a /\ (b /\ c)`))
    (def th_a (RAndElim1 goal2))
    (def th_bc (RAndElim2 goal2))
    (def th_b (cut th_bc (RAndElim1 th_bc)))
    (def th_c (cut th_bc (RAndElim2 th_bc)))
    (def th_ab (RAndIntro th_a th_b))
    (def th2 (RAndIntro th_ab th_c))

    (bool_eq_intro th1 th2)
  })

(defn RAndAssoc [a b c]
  (doc "Takes `a` `b` and `c` and returns `(a/\b)/\c = a/\(b/\c")
  (subst AndAssoc "a" a "b" b "c" c))

; prove `a /\ b = b /\ a`
(set AndComm
  {
    (def goal1 (assume `with a b: bool. a /\ b`))
    (def th_a (RAndElim1 goal1))
    (def th_b (RAndElim2 goal1))
    (def th1 (RAndIntro th_b th_a))
    ; other case is exactly the same
    (def th2 (subst th1 "a" `b:bool` "b" `a:bool`))
    (bool_eq_intro th1 th2)
  })

(defn RAndComm [a b]
  (doc "Takes `a` and `b` and returns `a/\b = b/\a")
  (subst AndComm "a" a "b" b))

; prove `a |- a /\ T` and `a |- T /\ a`
{
  (def th_a (assume `a:bool`))
  (set AndTrueRight (RAndIntro th_a TrueIsTrue))
  (set AndTrueLeft (RAndIntro TrueIsTrue th_a))
}

{
  (def hypa (assume `a:bool`))
  (def hypb (assume `b:bool`))
  (def hypab (assume `a:bool /\ b:bool`))
  (def and_eq
    (rw (congr DefAnd (refl `a:bool`) (refl `b:bool`)) :beta))
  (def thforall (bool_eq hypab and_eq))

  ; get `a |- a=T`
  (def a_true (REqTrueIntro hypa))
  (def b_true (REqTrueIntro hypb))

  ; using `a/\b = forall f. f a b = f T T`, instantiate `f`.
  ; We want to prove `a/\b |- a=b`.
  (def a_eq_b1
    (rw (RForallSubst thforall `with a:bool. \x y:bool. a = y`) :beta))

  ; `a, a/\b |- b`
  (set CutAndRight
    (bool_eq (assume `a:bool`) (bool_eq a_true (sym a_eq_b1))))

  (def b_eq_a1
    (rw (RForallSubst thforall `with b:bool. \x y:bool. b = x`) :beta))

  ; `b, a/\b |- a`
  (set CutAndLeft
    (bool_eq (assume `b:bool`) (bool_eq b_true (sym b_eq_a1))))
}

(defn RCutAndRight [a b]
  (doc "takes `a` and `b` and returns `a, a/\b |- b`")
  (subst CutAndRight "a" a "b" b))

(defn RCutAndLeft [a b]
  (doc "takes `a` and `b` and returns `b, a/\b |- a`")
  (subst CutAndLeft "a" a "b" b))


; `a |- (a/\b) = b`
{
  (def h1 (assume `a:bool`))
  ; prove `a |- (a/\b)=b`

  (def ltor (RCutAndRight `a:bool` `b:bool`))
  (def rtol (RAndIntro (assume `a:bool`) (assume `b:bool`)))
  (set AProveAAndBEqB (bool_eq_intro ltor rtol))
}

; from `a` and `b` to `a |- (a/\b)=b`
(defn RAProveAAndBEqB [a b]
  (doc "takes boolean terms `a` and `b` and returns `a |- (a/\b)=b`")
  (subst AProveAAndBEqB "a" a "b" b))

; #### false ####

; define false
(defconst "F" "DefFalse" `forall p:bool. p`)

(defn FalseElim [th p]
  (doc "takes `|- F` and a term `p`, and returns `|- p`")
  (def h_allp (bool_eq th DefFalse))
  (RForallSubst h_allp p))

; #### implication ####

; define implication
(defconst "==>" "DefImply" `\a b:bool. (a /\ b) = a`)
(set_infix "==>" 20 19)

; instantiates `a ==> b = …`
(defn RImplyDefSubst [a b]
  (doc "expand def of `==>`: takes `a` and `b` and instantiates `(a ==> b) = ((a/\b)=a)`")
  (rw (congr DefImply (refl a) (refl b)) :beta))

; prove `a, a ==> b |- b`
(set ImplyElim {
  (def ha (assume `a:bool`))
  (def hypab (assume `a:bool ==> b:bool`))
  (def def_exp
    (rw (congr DefImply (refl `a:bool`) (refl `b:bool`)) :beta))
  ; `|- a/\b=a`
  (def a_and_b_eq_a (bool_eq hypab def_exp))
  ; `a |- a=T`
  (def a_eq_t (REqTrueIntro ha))
  (def r (trans a_and_b_eq_a a_eq_t))
  (def r (REqTrueElim r))
  (cut r (RAndElim2 r))
})

; from `F |- b` and `a`, to `F \ {a} |- a==>b`
(defn RImplyIntro [th a]
  (doc "takes `F, a|-b` and `a` and returns `F |- a==>b`")
  (def b (concl th))
  ; a |- a/\b
  (def h1 (RAndIntro (assume a) th))
  ; a/\b |- a
  (def h2 (RAndElim1 (assume (e_app (e_app `$/\` a) b))))
  ; (a/\b)=a
  (def conj (bool_eq_intro h2 h1))
  (def def_imp (sym (RImplyDefSubst a b)))
  (def res (bool_eq conj def_imp))
  res)

(defn MP [th1 th2]
  (doc "takes `|- a==>b` and `|- a` and returns `|- b`")
  (def a (concl th2))
  (def b (e_app_rhs (concl th1)))
  (cut th1 th2 (subst ImplyElim "a" a "b" b)))

(defn RImplyElim [th]
  (doc "takes `F |- a==>b` and returns `F, a |- b`")
  (def a (e_app_rhs (e_app_lhs (concl th))))
  (cut th (MP th (assume a))))

(set ImplyImpliesImply
  (def t `a:bool ==> b:bool`)
  (def h (assume t))
  (RImplyIntro h t))

(defn RImplyImpliesImply [a b]
  (doc "takes `a` and `b` and returns `|- (a==>b) ==> a ==> b`")
  (subst ImplyImpliesImply "a" a "b" b))

; #### negation ####

(defconst "~" "DefNot" `\p:bool. p ==> F`)
(set_prefix "~" 62)

; expand definition of ~
(defn RNotDefSubst [x]
  (doc "expand def of `~`: takes `t` and returns `~t = (t==>F)`")
  (rw (congr DefNot (refl x)) :beta))

; prove ~ (T=F)
(set NotTrueEqFalse
  ; prove `T=F ==> F`
  (def h0 (assume `T=F`))
  (def h1 (bool_eq TrueIsTrue h0))
  (def h2 (RImplyIntro h1 `T=F`))
  (def teqf (RNotDefSubst `T = F`))
  (bool_eq h2 (sym teqf)))

(defconst "\/" "DefOr" `\a b: bool. forall t: bool. (a ==> t) ==> (b ==> t) ==> t`)
(set_infix "\/" 22 21)

; def of `\/`
(defn ROrDefSubst [x y]
  (doc "expands def of `\/`: takes `x` and `y` and returns `x\/y = …`")
  (rw (congr DefOr (refl x) (refl y)) :beta))

; prove `a |- a\/b`
(set AProveAOrB
  (def a `a:bool`)
  (def b `b:bool`)
  (def r `r:bool`)
  (def h0 (RImplyImpliesImply a r))
  (def h1 (RImplyElim h0))
  (def h1 (RImplyElim h1))
  (def h2 (RImplyIntro h1 `b:bool ==> r:bool`))
  (def h3 (RImplyIntro h2 `a:bool ==> r:bool`))
  (def h4 (RForallIntro h3 r))
  (def defor (ROrDefSubst a b)) ; def `a\/b`
  (bool_eq h4 (sym defor)))

; from `|- a` to `|- a\/b`
(defn ROrIntro1 [th b]
  (doc "takes `F |- a` and `b` and returns `F |- a\/b`")
  (def a (concl th))
  (cut th (subst AProveAOrB "a" a "b" b)))

; prove `b |- a\/b`
(set BProveAOrB
  (def a `a:bool`)
  (def b `b:bool`)
  (def r `r:bool`)
  (def h0 (RImplyImpliesImply b r))
  (def h1 (RImplyElim h0))
  (def h1 (RImplyElim h1))
  (def h2 (RImplyIntro h1 `b:bool ==> r:bool`))
  (def h3 (RImplyIntro h2 `a:bool ==> r:bool`))
  (def h4 (RForallIntro h3 r))
  (def defor (ROrDefSubst a b)) ; def `a\/b`
  (bool_eq h4 (sym defor)))

; from `|-b` to `|- a\/b`
(defn ROrIntro2 [th a]
  (doc "takes `F |- b` and `a` and returns `F |- a\/b`")
  (def b (concl th))
  (cut th (subst BProveAOrB "a" a "b" b)))

; \/ is commutative
(set OrComm
  (def a `a:bool`)
  (def b `b:bool`)
  ; direct: a\/b |- b\/a
  (def direct
    (def h1 (assume `a:bool \/ b:bool`))
    (def h2 (bool_eq h1 (ROrDefSubst a b)))
    ; prove a
    (def h2 (RForallSubst h2 `b:bool \/ a:bool`))
    (def r1 (RImplyIntro (ROrIntro1 (assume b) a) b))
    (def r2 (RImplyIntro (ROrIntro2 (assume a) b) a))
    (MP (MP h2 r2) r1))
  (def indirect (subst direct "a" b "b" a))
  (bool_eq_intro direct indirect))

; from `a\/b` to `b\/a`
(defn ROrComm [th]
  (doc "takes `F |- a\/b` and returns `F |- b\/a`")
  (def a (e_app_rhs (e_app_lhs (concl th))))
  (def b (e_app_rhs (concl th)))
  (bool_eq th (subst OrComm "a" a "b" b)))

; TODO: lemmas about \/

; #### select ####

; declare `select`
(decl "select" `pi a. (a -> bool) -> a`)
(set_binder "select" 41)


; Map over a list
(defn map [f l]
  (doc "(map f l) maps f over list l")
  (if (nil? l) nil (cons (f (car l)) (map f (cdr l)))))

(defn fold [f acc l]
  (doc "(fold f acc l) left-folds f over l with accumulator acc.")
  (if (nil? l) acc
    (become fold f (f acc (car l)) (cdr l))))

; # END OF FILE
; # avoid double include
(set hol_prelude_loaded true)
