; vim:ft=trustee:

; ### The HOL prelude for Trustee.


(defconst
  "T" "DefTrue"
  `let f = (\x: bool. x) in f=f`)

; `|- T`
(defthm "TrueIsTrue"
  (bool_eq
    (refl `\x: bool. x`)
    (sym DefTrue)))

; prove `(x=T) = x`
(defthm "EqTrueElim"
  (bool_eq_intro
    (bool_eq TrueIsTrue (sym (assume `with x:bool. x=T`)))
    (bool_eq_intro TrueIsTrue (assume `with x:bool. x`))))

;eq_true_elim

; prove `(x=T) = x`
(defthm "EqTrueElim"
  (bool_eq_intro
    (bool_eq TrueIsTrue (sym (assume `with x:bool. x=T`)))
    (bool_eq_intro TrueIsTrue (assume `with x:bool. x`))))

; `x = (x=T)`
(defthm "EqTrueIntro" (sym EqTrueElim))

; rule from `A |- x` to `A |- x=T`
(defn REqTrueIntro [th]
  (def x (concl th))
  (def th1 (subst EqTrueIntro ["x" x]))
  (bool_eq th th1))

; rule from `A |- x=T` to `A |- x`
(defn REqTrueElim [th]
  (print (concl th))
  (def x (app_rhs (app_lhs (concl th))))
  (def th1 (subst EqTrueElim ["x" x]))
  (bool_eq th th1))

(defconst "forall" "DefForall"
 `\(a:type) (f:a -> bool). f = (\x:a. T)`)
(set_binder "forall" 12) ; lower than ==>

; takes `|- forall x. P` and `e`, and returns `|- P[e/x]`.
(defn ForallSubst [th e]
  (def lamF (rw [:beta DefForall] th))
  (def eq (rw [:beta] (congr lamF (refl e))))
  (def eq2 (REqTrueElim eq))
  eq2)

(defconst "/\" "DefAnd"
  `\a b: bool. forall (f:bool->bool->bool). (f a b = f T T)`)
(set_infix "/\" 60 59)

; theorems on `/\`
{
  ; build `a/\b = â€¦` from definition
  (def ab_def
    (congr DefAnd (refl `a:bool`) (refl `b:bool`)))

  (def goal (assume `a:bool /\ b:bool`))

  ; this gets `a/\b |- \f. f a b = \f. f T T`
  (def f_eq
    (rw [DefForall :beta] (bool_eq goal ab_def)))

  ; prove: `a/\b |- a`

  ; apply f_eq to `\x y. x=a`
  (def a_true
    (rw [:beta] (congr f_eq (refl `with a:bool. \x y: bool. (a = x)`))))

  (defthm "AndElim1"
    (bool_eq
      (bool_eq
       (refl `a:bool`)
       (bool_eq a_true
         (subst EqTrueElim ["x" `with a:bool. (a=a) = (a=T)`])))
      (subst EqTrueElim ["x" `a:bool`])))

  ;(print (findthm "bool_elim1"))

  ; prove: `a/\b |- b`
  (def b_true
    ; apply f_eq to `\x y. y=b`
    (rw [:beta] (congr f_eq (refl `with b:bool. \x y:bool. (b=y)`))))

  (defthm "AndElim2"
    (bool_eq
      (bool_eq
       (refl `b:bool`)
       (bool_eq b_true (subst EqTrueElim ["x" `with b:bool. (b=b)=(b=T)`])))
      (subst EqTrueElim ["x" `b:bool`])))

  ;(print (findthm "bool_elim2"))
}

; rule from `A |- a /\ b` to `A |- a`
(defn RAndElim1 [th]
  (def c (concl th))
  (def a (app_rhs (app_lhs c)))
  (def b (app_rhs c))
  (subst AndElim1 ["a" a "b" b]))

; rule from `A |- a /\ b` to `A |- b`
(defn RAndElim2 [th]
  (def c (concl th))
  (def a (app_rhs (app_lhs c)))
  (def b (app_rhs c))
  (subst AndElim2 ["a" a "b" b]))

; theorem `a, b |- a /\ b`
(defthm "AndIntro"
  {
    (def tha (REqTrueIntro (assume `a:bool`)))
    (def thb (REqTrueIntro (assume `b:bool`)))
    (def th1 (rw [DefForall :beta] (congr DefAnd tha thb)))
    ; prove `(\f. f T T = f T T) = (\f. T)`
    (def lemma1
      (def lhs (refl `with f: bool->bool->bool. f T T`))
      (def c (REqTrueIntro lhs))
      (absv `f:(bool->bool->bool)` c))
    (bool_eq lemma1 (sym th1))
  })

; rule from `A |- a`, `B |- b` to `A, B |- a /\ b`
(defn RAndIntro [tha thb]
  (def a (concl tha))
  (def b (concl thb))
  (subst AndIntro ["a" a "b" b]))

; example:
; (print (cut TrueIsTrue (RAndIntro (assume `T`) (assume `b:bool`))))
; print: `with (b : bool). b |- with (b : bool). T /\ b`

; prove `(a /\ b) /\ c) = a /\ (b /\ c)`
(defthm "AndAssoc"
  {
    ; direct direction
    (def goal1 (assume `with a b c: bool. (a /\ b) /\ c`))
    (def th_c (RAndElim2 goal1))
    (def th_ab (RAndElim1 goal1))
    (def th_a (cut th_ab (RAndElim1 th_ab)))
    (def th_b (cut th_ab (RAndElim2 th_ab)))
    (def th_bc (cut th_b th_c (RAndIntro th_b th_c)))
    (def th1 (cut th_a th_bc (RAndIntro th_a th_bc)))

    (def goal2 (assume `with a b c: bool. a /\ (b /\ c)`))
    (def th_a (RAndElim1 goal2))
    (def th_bc (RAndElim2 goal2))
    (def th_b (cut th_bc (RAndElim1 th_bc)))
    (def th_c (cut th_bc (RAndElim2 th_bc)))
    (def th_ab (cut th_a th_b (RAndIntro th_a th_b)))
    (def th2 (cut th_c th_ab (RAndIntro th_ab th_c)))

    (bool_eq_intro th1 th2)
  })

; prove `a /\ b = b /\ a`
(defthm "AndComm"
  {
    (def goal1 (assume `with a b: bool. a /\ b`))
    (def th_a (RAndElim1 goal1))
    (def th_b (RAndElim2 goal1))
    (def th1 (RAndIntro th_b th_a))
    (def th2 (subst th1 ["a" `b:bool` "b" `a:bool`]))
    (bool_eq_intro th1 th2)
  })

; prove `a |- a /\ T` and `a |- T /\ a`
{
  (def th_a (assume `a:bool`))
  (defthm "AndTrueRight" (RAndIntro th_a TrueIsTrue))
  (defthm "AndTrueLeft" (RAndIntro TrueIsTrue th_a))
}

{
  (def hypa (assume `a:bool`))
  (def hypb (assume `b:bool`))
  (def hypab (assume `a:bool /\ b:bool`))
  (def and_eq
    (rw [:beta] (congr DefAnd (refl `a:bool`) (refl `b:bool`))))
   ; (bool_eq
   ;   th_imp
   ;   (rw [:beta] (congr DefImply (refl a) (refl b)))))
  (def thforall (bool_eq hypab and_eq))

  ; get `a |- a=T`
  (def a_true (REqTrueIntro hypa))
  (def b_true (REqTrueIntro hypb))

  ; using `a/\b = forall f. f a b = f T T`, instantiate `f`.
  ; We want to prove `a/\b |- a=b`.
  (def a_eq_b1
    (rw [:beta] (ForallSubst thforall `with a:bool. \x y:bool. a = y`)))

  ; `a, a/\b |- b`
  (defthm "CutAndRight"
    (bool_eq (assume `a:bool`) (bool_eq a_true (sym a_eq_b1))))

  (def b_eq_a1
    (rw [:beta] (ForallSubst thforall `with b:bool. \x y:bool. b = x`)))

  ; `b, a/\b |- a`
  (defthm "CutAndLeft"
    (bool_eq (assume `b:bool`) (bool_eq b_true (sym b_eq_a1))))
}

; takes `a` and `b` and returns `a, a/\b |- b`
(defn RCutAndRight [a b]
  (subst CutAndRight ["a" a "b" b]))

; takes `a` and `b` and returns `b, a/\b |- a`
(defn RCutAndLeft [a b]
  (subst CutAndLeft ["a" a "b" b]))


; `a |- (a/\b) = b`
{
  (def h1 (assume `a:bool`))
  ; prove `a |- (a/\b)=b`

  (def ltor (RCutAndRight `a:bool` `b:bool`))
  (def rtol (RAndIntro (assume `a:bool`) (assume `b:bool`)))
  (defthm "AImpAAndBEqB" (bool_eq_intro ltor rtol))
}

; false
(defconst "F" "DefFalse" `forall p:bool. p`)

; TODO: false intro, false elim

; define implication
(defconst "==>" "DefImply" `\a b:bool. (a /\ b) = b`)
(set_infix "==>" 20 19)
; # TODO: go from `|- a ==> b` to `a |- b`, and conversely

(defconst "\/" "DefOr" `\a b: bool. forall t: bool. (a ==> t) ==> (b ==> t) ==> t`)
(set_infix "\/" 22 21)
; TODO: lemmas about \/

; negation

(defconst "~" "DefNot" `\p:bool. p ==> F`)
(set_prefix "~" 62)

; declare `select`
(decl "select" `pi a. (a -> bool) -> a`)
(set_binder "select" 41)


; # END OF FILE
; # avoid double include
(decl "hol_prelude_loaded" `bool`)
