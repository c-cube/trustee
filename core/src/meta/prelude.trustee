; vim:ft=trustee:

; ## The HOL prelude for Trustee.

; #### Helper rules ####

(defn RAppLeft [f th]
  (doc "takes $f$ and $|- t=u$ and returns $|- f t = f u$")
  (congr (refl f) th))

(defn RAppRight [th t]
  (doc "takes $|- f=g$ and $t$ and returns $|- f t = g t$")
  (congr th (refl t)))

; #### true ####

(defconst
  "T" "DefTrue" []
  $let f = (\x: bool. x) in f=f$)

; $|- T$
(set TrueIsTrue
  (bool_eq
    (refl $\x: bool. x$)
    (sym DefTrue)))

; prove $(x=T) = x$
(set EqTrueElim
  (bool_eq_intro
    (bool_eq TrueIsTrue (sym (assume $with x:bool. x=T$)))
    (bool_eq_intro TrueIsTrue (assume $with x:bool. x$))))

; $x = (x=T)$
(set EqTrueIntro (sym EqTrueElim))

; rule from $A |- x$ to $A |- x=T$
(defn REqTrueIntro [th]
  (doc "rule from $A |- x$ to $A |- x=T$")
  (def x (concl th))
  (def th1 (subst EqTrueIntro "x" x))
  (bool_eq th th1))

(defn REqTrueElim [th]
  (doc "rule from $A |- x=T$ to $A |- x$")
  (match (concl th)
   (case $= _ ?x T$
    (def th1 (subst EqTrueElim "x" x))
    (bool_eq th th1))
   (else (fail "true elim: concl must be $x=T$"))))

; #### forall ####

(defconst "forall" "DefForall" ["a"]
 $(f:a -> bool). f = (\x:a. T)$)
(set_binder "forall" 12) ; lower than ==>

(defn RForallSubst [th e]
  (doc "rule that takes $|- forall x. P[x]$ and $e$, and returns $|- P[e/x]$.")
  (def lamF (rw th :beta DefForall))
  (def eq (rw (congr lamF (refl e)) :beta))
  (def eq2 (REqTrueElim eq))
  eq2)

(defn RForallIntro [th x]
  (doc "rule that takes $F |- P[x]$ and $x$ with $x$ not in $fvars(F)$, and returns $F |- forall x. P[x]$.")
  ; build $\x. P[x]$
  (def P (e_abs x (concl th)))
  ; get $($forall P) = (\x. P[x] = \x. T)
  (def forallp (rw (congr (congr_ty DefForall (expr_ty x)) (refl P)) :beta))
  ; get $F |- \x. P[x] = \x. T$
  (def peqt (absv x (REqTrueIntro th)))
  (def res (bool_eq peqt (sym forallp)))
  res)

; #### conjunction ####

(defconst "/\" "DefAnd" []
  $\a b: bool. forall (f:bool->bool->bool). (f a b = f T T)$)
(set_infix "/\" 60 59)

; theorems on $/\$
{
  ; build $a/\b = …$ from definition
  (def ab_def
    (congr DefAnd (refl $a:bool$) (refl $b:bool$)))

  (def goal (assume $a:bool /\ b:bool$))

  ; this gets $a/\b |- \f. f a b = \f. f T T$
  (def f_eq
    (rw (bool_eq goal ab_def) DefForall :beta))

  ; prove: $a/\b |- a$

  ; apply f_eq to $\x y. x=a$
  (def a_true
    (rw (congr f_eq (refl $with a:bool. \x y: bool. (a = x)$)) :beta))

  (set AndElim1
    (bool_eq
      (bool_eq
       (refl $a:bool$)
       (bool_eq a_true
         (subst EqTrueElim "x" $with a:bool. (a=a) = (a=T)$)))
      (subst EqTrueElim "x" $a:bool$)))

  ; prove: $a/\b |- b$
  (def b_true
    ; apply f_eq to $\x y. y=b$
    (rw (congr f_eq (refl $with b:bool. \x y:bool. (b=y)$)) :beta))

  (set AndElim2
    (bool_eq
      (bool_eq
       (refl $b:bool$)
       (bool_eq b_true (subst EqTrueElim "x" $with b:bool. (b=b)=(b=T)$)))
      (subst EqTrueElim "x" $b:bool$)))
}

(defn RAndElim1 [th]
  (doc "rule from $A |- a /\ b$ to $A |- a$")
  (match (concl th)
   (case $/\ ?a ?b$
    (subst AndElim1 "a" a "b" b))
   (else (fail "and elim1: expect /\ in concl"))))

(defn RAndElim2 [th]
  (doc "rule from $A |- a /\ b$ to $A |- b$")
  (match (concl th)
   (case $/\ ?a ?b$ (subst AndElim2 "a" a "b" b))
   (else (fail "and elim2: expect /\ in concl"))))

; theorem $a, b |- a /\ b$
(set AndIntro
  (def tha (REqTrueIntro (assume $a:bool$)))
  (def thb (REqTrueIntro (assume $b:bool$)))
  (def th1 (rw (congr DefAnd tha thb) DefForall :beta))
  ; prove $(\f. f T T = f T T) = (\f. T)$
  (def lemma1
    (def lhs (refl $with f: bool->bool->bool. f T T$))
    (def c (REqTrueIntro lhs))
    (absv $f:(bool->bool->bool)$ c))
  (bool_eq lemma1 (sym th1)))

(defn RAndIntro [tha thb]
  (doc "rule from $A |- a$, $B |- b$ to $A, B |- a /\ b$")
  (def a (concl tha))
  (def b (concl thb))
  (cut tha thb (subst AndIntro "a" a "b" b)))

; example:
; (print (cut TrueIsTrue (RAndIntro (assume $T$) (assume $b:bool$))))
; print: $with (b : bool). b |- with (b : bool). T /\ b$

; prove $(a /\ b) /\ c) = a /\ (b /\ c)$
(set AndAssoc
  ; direct direction
  (def goal1 (assume $with a b c: bool. (a /\ b) /\ c$))
  (def th_c (RAndElim2 goal1))
  (def th_ab (RAndElim1 goal1))
  (def th_a (cut th_ab (RAndElim1 th_ab)))
  (def th_b (cut th_ab (RAndElim2 th_ab)))
  (def th_bc (RAndIntro th_b th_c))
  (def th1 (RAndIntro th_a th_bc))

  (def goal2 (assume $with a b c: bool. a /\ (b /\ c)$))
  (def th_a (RAndElim1 goal2))
  (def th_bc (RAndElim2 goal2))
  (def th_b (cut th_bc (RAndElim1 th_bc)))
  (def th_c (cut th_bc (RAndElim2 th_bc)))
  (def th_ab (RAndIntro th_a th_b))
  (def th2 (RAndIntro th_ab th_c))

  (bool_eq_intro th1 th2))

(defn RAndAssoc [a b c]
  (doc "Takes $a$ $b$ and $c$ and returns $(a/\b)/\c = a/\(b/\c")
  (subst AndAssoc "a" a "b" b "c" c))

; prove $a /\ b = b /\ a$
(set AndComm
  (def goal1 (assume $with a b: bool. a /\ b$))
  (def th_a (RAndElim1 goal1))
  (def th_b (RAndElim2 goal1))
  (def th1 (RAndIntro th_b th_a))
  ; other case is exactly the same
  (def th2 (subst th1 "a" $b:bool$ "b" $a:bool$))
  (bool_eq_intro th1 th2))

(defn RAndComm [a b]
  (doc "Takes $a$ and $b$ and returns $a/\b = b/\a")
  (subst AndComm "a" a "b" b))

; prove $a |- a /\ T$ and $a |- T /\ a$
(set AndTrueRight (RAndIntro (assume $a:bool$) TrueIsTrue))
(set AndTrueLeft (RAndIntro TrueIsTrue (assume $a:bool$) ))

{
  (def hypa (assume $a:bool$))
  (def hypb (assume $b:bool$))
  (def hypab (assume $a:bool /\ b:bool$))
  (def and_eq
    (rw (congr DefAnd (refl $a:bool$) (refl $b:bool$)) :beta))
  (def thforall (bool_eq hypab and_eq))

  ; get $a |- a=T$
  (def a_true (REqTrueIntro hypa))
  (def b_true (REqTrueIntro hypb))

  ; using $a/\b = forall f. f a b = f T T$, instantiate $f$.
  ; We want to prove $a/\b |- a=b$.
  (def a_eq_b1
    (rw (RForallSubst thforall $with a:bool. \x y:bool. a = y$) :beta))

  ; $a, a/\b |- b$
  (set CutAndRight
    (bool_eq (assume $a:bool$) (bool_eq a_true (sym a_eq_b1))))

  (def b_eq_a1
    (rw (RForallSubst thforall $with b:bool. \x y:bool. b = x$) :beta))

  ; $b, a/\b |- a$
  (set CutAndLeft
    (bool_eq (assume $b:bool$) (bool_eq b_true (sym b_eq_a1))))
}

(defn RCutAndRight [a b]
  (doc "takes $a$ and $b$ and returns $a, a/\b |- b$")
  (subst CutAndRight "a" a "b" b))

(defn RCutAndLeft [a b]
  (doc "takes $a$ and $b$ and returns $b, a/\b |- a$")
  (subst CutAndLeft "a" a "b" b))


; $a |- (a/\b) = b$
(set AProveAAndBEqB
  (def h1 (assume $a:bool$))
  ; prove $a |- (a/\b)=b$

  (def ltor (RCutAndRight $a:bool$ $b:bool$))
  (def rtol (RAndIntro (assume $a:bool$) (assume $b:bool$)))
  (bool_eq_intro ltor rtol))

; from $a$ and $b$ to $a |- (a/\b)=b$
(defn RAProveAAndBEqB [a b]
  (doc "takes boolean terms $a$ and $b$ and returns $a |- (a/\b)=b$")
  (subst AProveAAndBEqB "a" a "b" b))

; #### false ####

; define false
(defconst "F" "DefFalse" [] $forall p:bool. p$)

(defn RFalseElim [th p]
  (doc "takes $|- F$ and a term $p$, and returns $|- p$")
  (def h_allp (bool_eq th DefFalse))
  (RForallSubst h_allp p))


; #### implication ####

; define implication
(defconst "==>" "DefImply" [] $\a b:bool. (a /\ b) = a$)
(set_infix "==>" 20 19)

; instantiates $a ==> b = …$
(defn RImplyDefSubst [a b]
  (doc "expand def of $==>$: takes $a$ and $b$ and instantiates $(a ==> b) = ((a/\b)=a)$")
  (rw (congr DefImply (refl a) (refl b)) :beta))

; prove $a, a ==> b |- b$
(set ImplyElim
  (def ha (assume $a:bool$))
  (def hypab (assume $a:bool ==> b:bool$))
  (def def_exp
    (rw (congr DefImply (refl $a:bool$) (refl $b:bool$)) :beta))
  ; $|- a/\b=a$
  (def a_and_b_eq_a (bool_eq hypab def_exp))
  ; $a |- a=T$
  (def a_eq_t (REqTrueIntro ha))
  (def r (trans a_and_b_eq_a a_eq_t))
  (def r (REqTrueElim r))
  (cut r (RAndElim2 r)))

; from $F |- b$ and $a$, to $F \ {a} |- a==>b$
(defn RImplyIntro [th a]
  (doc "takes $F, a|-b$ and $a$ and returns $F |- a==>b$")
  (def b (concl th))
  ; a |- a/\b
  (def h1 (RAndIntro (assume a) th))
  ; a/\b |- a
  (def h2 (RAndElim1 (assume (e_app (e_app $@/\$ a) b))))
  ; (a/\b)=a
  (def conj (bool_eq_intro h2 h1))
  (def def_imp (sym (RImplyDefSubst a b)))
  (def res (bool_eq conj def_imp))
  res)

(defn MP [th1 th2]
  (doc "takes $|- a==>b$ and $|- a$ and returns $|- b$")
  (match (concl th1)
   (case $==> ?a ?b$
     (cut th1 th2 (subst ImplyElim "a" a "b" b)))
   (else (fail "MP: expect first theorem to be an implication"))))

(defn RImplyElim [th]
  (doc "takes $F |- a==>b$ and returns $F, a |- b$")
  (match (concl th)
   (case $==> ?a _$ (MP th (assume a)))
   (else (fail "imply elim: theorem is not an implication"))))

(defn RImplyElimRep [th]
  (doc "takes $F |- a1==>…==>an==>b$ and returns $F, a1…an |- b$")
  (match (concl th)
   (case $==> ?a _$
     (def th2 (MP th (assume a)))
     (become RImplyElimRep th2))
   (else th)))

; $(a ==> b) ==> a ==> b$
(set ImplyImpliesImply
  (def t $a:bool ==> b:bool$)
  (def h (assume t))
  (RImplyIntro h t))

(defn RImplyImpliesImply [a b]
  (doc "takes $a$ and $b$ and returns $|- (a==>b) ==> a ==> b$")
  (subst ImplyImpliesImply "a" a "b" b))

; $|- a ==> a$
(set AImplyA
  (def h (assume $a:bool$))
  (RImplyIntro h $a:bool$))

(defn RImplyReflexive [p]
  (doc "takes $p$ and returns $|- p ==> p$")
  (def h (assume p))
  (RImplyIntro h p))

; $a==>b$, $b==>c$, gives $a==>c$
(defn RImplyTrans [th1 th2]
  (doc "takes $|- a==>b$ and $|- b==>c$ to return $|- a==>c")
  (match (concl th1)
   (case $==> ?a _$
    (RImplyIntro (MP th2 (RImplyElim th1)) a))
   (else (fail "imply trans: needs first theorem to be an implication"))))

; takes $p$ and returns $|- F ==> p$
(defn RFalseImply [p]
  (doc "takes $p$ and returns $|- F ==> p$")
  (RImplyIntro (RFalseElim (assume $F$) p) $F$))

; #### negation ####

(defconst "~" "DefNot" [] $\p:bool. p ==> F$)
(set_prefix "~" 62)

; expand definition of ~
(defn RNotDefSubst [x]
  (doc "expand def of $~$: takes $t$ and returns $~t = (t==>F)$")
  (rw (RAppRight DefNot x) :beta))

; prove $|- ~ F$
(set NotFalse
  (def heq (sym (RNotDefSubst $F$)))
  (def fimpf (RImplyReflexive $F$))
  (bool_eq fimpf heq))

; $|- ~ F = T$
(set NotFalseEqTrue
  (bool_eq_intro TrueIsTrue NotFalse))

; from $|- P ==> F$ to $|- ~ P$
(defn RNotIntro [th]
  (doc "takes $|- p ==> F$ and returns $|- ~ p$")
  (match (concl th)
   (case $==> ?p F$
    (def h (RNotDefSubst p))
    (bool_eq th (sym h)))
   (else (fail "not intro: expect conclusion $p ==> F$"))))

; $|- ~ P$ to $|- P ==> F$
(defn RNotElim [th]
  (doc "takes $|- ~ P$ and returns $|- P ==> F$")
  (match (concl th)
   (case $~ ?p$
    (def h (RNotDefSubst p))
    (bool_eq th h))
   (else (fail "not elim: expect $~ p$ as concl"))))

; TODO: a rule from $a |- F$ to $|- ~ a$

; prove ~ (T=F)
(set TrueNeqFalse
  ; prove $T=F ==> F$
  (def h0 (assume $T=F$))
  (def h1 (bool_eq TrueIsTrue h0))
  (def h2 (RImplyIntro h1 $T=F$))
  (def teqf (RNotDefSubst $T=F$))
  (bool_eq h2 (sym teqf)))

(set AImplyNotNotA
  ; ~~a = (a==>F)==>F
  (def dnotnota
    (def n1 (RNotDefSubst $a:bool$))
    (def n2 (RNotDefSubst $a:bool ==> F$))
    (def n1c (RAppLeft $@~$ n1))
    (trans n1c n2))
  (def h1 (assume $a:bool ==> F$))
  (def h2 (RImplyElim h1))
  (def h3 (RImplyIntro h2 $a:bool ==> F$))
  (def h4 (bool_eq h3 (sym dnotnota)))
  (RImplyIntro h4 $a:bool$))

; from $p$ to $|- p ==> ~ ~ p$
(defn RAImplyNotNotA [p]
  (doc "takes $p$ and returns $|- p ==> ~ ~ p$")
  (subst AImplyNotNotA "a" p))

; #### disjunction ####

(defconst "\/" "DefOr" [] $\a b: bool. forall t: bool. (a ==> t) ==> (b ==> t) ==> t$)
(set_infix "\/" 22 21)

; def of $\/$
(defn ROrDefSubst [x y]
  (doc "expands def of $\/$: takes $x$ and $y$ and returns $x\/y = …$")
  (rw (congr DefOr (refl x) (refl y)) :beta))

; prove $a |- a\/b$
(set AProveAOrB
  (def a $a:bool$)
  (def b $b:bool$)
  (def r $r:bool$)
  (def h0 (RImplyImpliesImply a r))
  (def h1 (RImplyElim h0))
  (def h1 (RImplyElim h1))
  (def h2 (RImplyIntro h1 $b:bool ==> r:bool$))
  (def h3 (RImplyIntro h2 $a:bool ==> r:bool$))
  (def h4 (RForallIntro h3 r))
  (def defor (ROrDefSubst a b)) ; def $a\/b$
  (bool_eq h4 (sym defor)))

; from $|- a$ to $|- a\/b$
(defn ROrIntro1 [th b]
  (doc "takes $F |- a$ and $b$ and returns $F |- a\/b$")
  (def a (concl th))
  (cut th (subst AProveAOrB "a" a "b" b)))

; prove $b |- a\/b$
(set BProveAOrB
  (def a $a:bool$)
  (def b $b:bool$)
  (def r $r:bool$)
  (def h0 (RImplyImpliesImply b r))
  (def h1 (RImplyElim h0))
  (def h1 (RImplyElim h1))
  (def h2 (RImplyIntro h1 $b:bool ==> r:bool$))
  (def h3 (RImplyIntro h2 $a:bool ==> r:bool$))
  (def h4 (RForallIntro h3 r))
  (def defor (ROrDefSubst a b)) ; def $a\/b$
  (bool_eq h4 (sym defor)))

; from $|- b$ to $|- a\/b$
(defn ROrIntro2 [th a]
  (doc "takes $F |- b$ and $a$ and returns $F |- a\/b$")
  (def b (concl th))
  (cut th (subst BProveAOrB "a" a "b" b)))

; the theorem $a\/b, a==>c, b==>c |- c$
(set OrElim
  (def a $a:bool$)
  (def b $b:bool$)
  (def c $c:bool$)
  (def def_aorb (ROrDefSubst a b))
  (def h (bool_eq (assume $with a b:bool. a\/b$) def_aorb))
  (def h1 (RForallSubst h c))
  (RImplyElim (RImplyElim h1)))

; or intro rule by case
(defn ROrElimByCase [thc th1 th2]
  (doc "takes $|- a\/b$, $|- a ==> p$, $|- b ==> p$, and returns $|- p$")
  (match (concl thc)
   (case $\/ ?a ?b$
    (match (concl th1)
     (case $==> _ ?p$
      (def th (subst OrElim "a" a "b" b "c" p))
      (cut th1 th2 thc th))
     (else (fail "or elim by case: th2 must be an implication"))))
   (else (fail "or elim by case: th0 must be a disjunction"))))

; or intro rule by case, with cuts
(defn ROrElimByCaseCut [thc th1 th2]
  (doc "takes $|- a\/b$, $a |- p$, $b |- p$, and returns $|- p$")
  (match (concl thc)
   (case $\/ ?a ?b$
    (become ROrElimByCase thc (RImplyIntro th1 a) (RImplyIntro th2 b)))
   (else (fail "or elim by case: th0 must be a disjunction"))))

; \/ is commutative
(set OrComm
  (def a $a:bool$)
  (def b $b:bool$)
  ; direct: a\/b |- b\/a
  (def direct
    (def h1 (assume $a:bool \/ b:bool$))
    (def r1 (ROrIntro1 (assume b) a))
    (def r2 (ROrIntro2 (assume a) b))
    (ROrElimByCaseCut h1 r1 r2))
  (def indirect (subst direct "a" b "b" a))
  (bool_eq_intro direct indirect))

; from $a\/b$ to $b\/a$
(defn ROrComm [th]
  (doc "takes $F |- a\/b$ and returns $F |- b\/a$")
  (match (concl th)
   (case $\/ ?a ?b$
    (bool_eq th (subst OrComm "a" a "b" b)))
   (else (fail "or comm: need a disjunction"))))

; (a\/b)\/c = a\/(b\/c)
(set OrAssoc
  (def a $a:bool$)
  (def b $b:bool$)
  (def c $c:bool$)
  (def ab $with a b:bool. a\/b$)
  (def bc $with b c:bool. b\/c$)
  (def direct
    (def h1 (assume $with a b c: bool. (a \/ b) \/ c$))
    ; a\/b |- a \/ (b\/c)
    (def c1
      (def h (assume ab))
      (def hbc (ROrIntro1 (assume b) c))
      (def bc_imp_abc (ROrIntro2 (assume bc) a))
      (def aimpabc (ROrIntro1 (assume a) bc))
      (def bimpabc (cut hbc bc_imp_abc))
      (ROrElimByCaseCut h aimpabc bimpabc))
    ; c |- a\/(b\/c)
    (def c2
      (def h1 (ROrIntro2 (assume c) b))
      (ROrIntro2 h1 a))
    (ROrElimByCaseCut h1 c1 c2))
  (def indirect
    (def h1 (assume $with a b c:bool. a\/(b\/c)$))
    ; a |- …
    (def c1 (ROrIntro1 (ROrIntro1 (assume a) b) c))
    (def c2
      (def h (assume bc))
      (def c21 (ROrIntro1 (ROrIntro2 (assume b) a) c))
      (def c22 (ROrIntro2 (assume c) ab))
      (ROrElimByCaseCut h c21 c22))
    (ROrElimByCaseCut h1 c1 c2))
  (bool_eq_intro direct indirect))

; #### excluded middle ####

; excluded middle axiom.
(set ExcludedMiddle (axiom $forall P:bool. P \/ ~P$))

; instantiate $x \/ ~x$
(defn RExcludedMiddle [x]
  (doc "apply excluded middle on given formula $P$ to get $|- P \/ ~P$")
  (RForallSubst ExcludedMiddle x))

; prove $~ ~ a = a$
(set NotNotAEqA
  ; indirect: $a |- ~ ~ a$
  (def hind (RImplyElim (RAImplyNotNotA $a:bool$)))

  ; direct: $~ ~ a |- a$
  ; use excluded middle on $~a$ to get $a \/ ~a$
  (def hex (RExcludedMiddle $a:bool$))
  ; case1: if we have $a$ we just return it
  (def case1 (RImplyReflexive $a:bool$))
  ; case2: if we have $~a$, since we also have $~~a$ by hyp, we can prove false
  (def hnn (bool_eq (assume $~ ~ a:bool$) (RNotDefSubst $~ a:bool$)))
  (def case2 (RImplyTrans hnn (RFalseImply $a:bool$)))
  (def hdir (ROrElimByCase hex case1 case2))

  (bool_eq_intro hdir hind))

; gets $|- ~ ~ p = p$
(defn RNotNotElimConv [p]
  (doc "takes $p$ and returns $|- ~ ~ p = p$")
  (subst NotNotAEqA "a" p))

; turns $|- ~ ~ p$ into $|- p$
(defn RNotNotElim [th]
  (doc "takes $|- ~ ~ p$ and returns $|- p$")
  (match (concl th)
    (case $~ (~ ?p)$ (bool_eq th (RNotNotElimConv p)))
    (else (fail "not not elim: expect $~ ~ p$"))))

; $|- ~ ~ T$
(set NotNotTrue
  (REqTrueElim (RNotNotElimConv $T$)))

; $~ T = F$
(set NotTrueEqFalse
  ; $F |- ~T$, easy
  (def hind (RImplyElim (RFalseImply $~ T$)))
  ; get $~ T |- F$
  (def h (RNotDefSubst $~ T$))
  (def h2 (bool_eq NotNotTrue h))
  (def hdir (RImplyElim h2))
  (bool_eq_intro hdir hind))

; goes from $~a |- F$ and $a$, to $|- a$
(defn RExFalso [th a]
  (doc "takes $G, ~a |- F$ and $a$, and returns $G |- a$")
  ; prove $G |- ~a = F$
  (def hindr (RImplyElim (RFalseImply (e_app $@~$ a))))
  (def h1 (bool_eq_intro th hindr))
  ; now, make that $G |- ~~a = ~F = T$
  (def h2 (RAppLeft $@~$ h1))
  (def h3 (trans h2 NotFalseEqTrue))
  ; |- ~~a
  (def h4 (REqTrueElim h3))
  (RNotNotElim h4))

; $(~a \/ b) = (a ==> b)$
(set OrNotEqImply
  (def direct
    (def h1 (assume $with a b:bool. ~a \/ b$))
    ; prove $~a |- a==>b$
    (def c1
      (def h (assume $~ a:bool$))
      (def h2 (RImplyElim (RNotElim h)))
      (def h3 (RFalseElim h2 $b:bool$))
      (RImplyIntro h3 $a:bool$))
    ; $b |- a ==> b$
    (def c2
      (RImplyIntro (assume $b:bool$) $a:bool$))
    (ROrElimByCaseCut h1 c1 c2))
  ; prove $a==>b |- ~a\/b$
  (def indirect
    (def h (assume $a:bool ==> b:bool$))
    (def ha (RExcludedMiddle $a:bool$))
    (def h1 (ROrIntro2 (MP h (assume $a:bool$)) $ ~a:bool$))
    (def h2 (ROrIntro1 (assume $~ a:bool$) $b:bool$))
    (ROrElimByCaseCut ha h1 h2))
    ;>>(ROrElimByCaseCut h1 c1 c2))
  (bool_eq_intro
  direct
  indirect))

(defn ROrNotEqImply [a b]
  (doc "takes $a$ and $b$ and returns $(~ a \/ b) = (a ==> b)$")
  (subst OrNotEqImply "a" a "b" b))

(defn RImplyToOrNot [th]
  (doc "takes $|- a ==> b$ and returns $|- ~a \/ b$")
  (match (concl th)
    (case $==> ?a ?b$
      (def ornot (ROrNotEqImply a b))
      (bool_eq th (sym ornot)))
    (else (fail "RImplyToOrNot requires $|- a ==> b$"))))



; TODO: de morgan laws

; #### select ####

; declare $select$
(decl "select" $pi a. (a -> bool) -> a$)
(set_binder "select" 41)


; #### list utils ####

; Map over a list
(defn list_map [f l]
  (doc "(map f l) maps f over list l")
  (match l
    (case (cons x l2) (cons x (list_map f l2)))
    (else nil)))

(defn list_fold [f acc l]
  (doc "(fold f acc l) left-folds f over l with accumulator acc.")
  (match l
    (case (cons x tl)
      (become list_fold f (f acc (car l)) (cdr l)))
    (else acc)))

; length of list
(defn list_len [l]
  (doc "length of input list")
  (match l
   (case (cons _ tl) (+ 1 (list_len tl)))
   (else 0)))

; iterate on list
(defn list_iter [f l]
  (doc "apply $f$ on each element of $l$")
  (match l
   (case (cons x tl)
     (f x)
     (become list_iter f tl))
   (else nil)))

(list_iter (fn [x] (print "x: " x)) [1 2 3 4])

; # END OF FILE
; # avoid double include, see $load_prelude_hol$ in $meta.rs$
(set hol_prelude_loaded true)
