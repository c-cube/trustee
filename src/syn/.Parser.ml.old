
open Trustee

module T = Trustee.Expr
module Fmt = CCFormat

type ctx = {
  ts: (string, T.t) Hashtbl.t;
}

let create () : ctx =
  { ts=Hashtbl.create 32; }

exception E_parse of string

let error_ msg = raise (E_parse msg)

module P = CCParse

let p_id = P.chars1_if P.is_alpha_num

let p_term (ctx:ctx) : T.t P.t =
  let open P.Infix in
  P.fix_memo
    (fun self ->
      P.skip_space *> (
      P.try_ ((P.string "type") *> P.return T.type_) <|>
      P.try_ ((P.string "true") *> P.return T.true_) <|>
      P.try_ ((P.string "false") *> P.return T.false_) <|>
      P.try_ (P.string "~" *> self >|= fun t -> T.not_ t) <|>
      P.try_ (P.char '(' *> P.skip_white *> (
          (P.try_ self >>= fun lhs ->
           let closing = P.skip_white <* P.char ')' in
           P.skip_white *> (
             P.try_ (P.char ')' *> P.return lhs) <|>
             P.try_ (P.string "->" *> self <* P.char ')' >|= fun rhs -> T.arrow lhs rhs) <|>
             P.try_ (P.string "=" *> self <* closing >|= fun rhs -> T.eq lhs rhs) <|>
             P.try_ (P.string "/\\" *> self <* closing >|= fun rhs -> T.and_ lhs rhs) <|>
             P.try_ (P.string "\\/" *> self <* closing >|= fun rhs -> T.or_ lhs rhs)
             <?> "expected infix term"
           ))))
        <|>
      P.try_
        (p_id >>= fun f ->
         try P.return (Hashtbl.find ctx.ts f)
         with Not_found -> P.failf "unknown identifier %S" f)
      <?> "expected a term"
    ))

let parse_term_exn ctx s : T.t =
  try P.parse_string_exn (p_term ctx) s
  with
  | P.ParseError (_, f) -> error_ @@ f()
  | Invalid_argument s -> error_ s

let parse_term ctx s =
  try Ok (parse_term_exn ctx s)
  with E_parse s -> Error s

let p_goal ctx : Goal.t P.t =
  let open P.Infix in
  P.skip_white *>
  (P.sep ~by:(P.char ',') (p_term ctx >|= fun t -> "",Thm.assume t)) >>= fun hyps ->
  P.skip_white *>
  P.string "|-" *>
  P.skip_white *>
  p_term ctx >|= fun concl ->
  Goal.make ~hyps concl

let parse_goal_exn ctx s : Goal.t =
  try P.parse_string_exn (p_goal ctx) s
  with P.ParseError (_, f) -> error_ @@ f()
  | Invalid_argument s -> error_ s

let parse_goal ctx s =
  try Ok (parse_goal_exn ctx s)
  with E_parse s -> Error s

type statement =
  | St_decl of Expr.t
  | St_prove of Goal.t

let p_statement ctx : statement P.t =
  let open P.Infix in
  P.skip_white *>
  (P.try_ (P.string "decl") *> P.skip_white *> p_id >>= fun f ->
   p_term ctx >>= fun ty ->
   if T.equal T.type_ ty || T.is_a_type ty then (
     let t = T.new_sym f ty in
     Hashtbl.add ctx.ts f t;
     P.return (St_decl t)
   ) else P.failf "decl: expected a type or kind, not %s" (Fmt.to_string T.pp ty))
  <|>
  (P.try_ (P.string "goal") *> p_goal ctx >|= fun g -> St_prove g)
  <?> "expected statement"

let parse_statement_exn ctx s : statement =
  try P.parse_string_exn (p_statement ctx) s
  with P.ParseError (_, f) -> error_ @@ f()
  | Invalid_argument s -> error_ s

let parse_statement ctx s =
  try Ok (parse_statement_exn ctx s)
  with E_parse s -> Error s
